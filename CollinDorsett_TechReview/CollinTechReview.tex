\documentclass[journal,10pt,onecolumn,compsoc]{IEEEtran} \usepackage[margin=1.0in]{geometry} \usepackage{pdfpages} \usepackage{graphicx} 
\graphicspath{/graphics} \setlength{\parskip}{\baselineskip} \setlength\parindent{24pt}
\usepackage[english]{babel}
%\usepackage{fullpage}

\title{VisualFlow Tech Review}
\author{Group 33: Collin Dorsett}
\date{\today}

\begin{document}
\maketitle
\section
% Debug Options: Probe vs Print Text vs None
% Probe: Allow the user to set 'breakpoints' that display variables passing through that point
% Print Text: Continually display variables and data passing through all points 
% None: Display no variables or data to the user (keeps everything simple and background)
\newpage
\noindent \textbf{Debugging}
\\
\\
\indent The first option we have chosen for debugging purposes is the probe. Our design of the probe would be to allow the user to place special Block type which displays different variables and data passing through that particular channel. In addition to simply displaying the content of the channel, we would also allow users to modifying existing variables at that point in the channel. Essentially, this means that they can feed in certain variables and data directly to other Blocks during runtime. The reason we considered this particular design for debugging is so that we can give the user a simple but highly effective means to debug their program. Compared to other debugging options we have examined, the probe is by far the most informative and give the user more control of their program. The ability to change variables and data on the fly as well as determine their output allows the user to quickly view mistakes and make subsequent fixes. On the other hand, however, the probe does present additional issues that are not prevalent in the other options. One such issue is that the user may accidentally forget to turn off/remove a probe. This means that whatever variable they have modified at that point will be fed into the program, and could very well result in incorrect results. One piece of technology we could use for this option is the Tkinter module for Python. This particular module was created specifically for use in GUI application development, and is available on most Unix and Windows platforms[1]. Additionally, Tkinter documentation is very thorough due to many develops utilizing it[1]. 
\\
\\
\indent Our second option for debugging is to simply print out variables and data for the user to view. Like the probe as mentioned previously, this design would allow the user to view different variables and data passing through that particular channel. Unlike the probe, however, using this option means that the user would be unable to modify variables and data during runtime. The reason that we chose this particular design option is that it remains fairly simple in that it gives users the option to view variables and data passing through a channel. Compared to other debugging options we have examined, this one remains informative while limiting the user's access to controlling the program. At first this may seem like a downside, but our goal is to stay simple, which this particular option does very well, even if it removes the option for variables and data manipulation. Similar to the probe option, this particular option could also utilize the Tkinter module. However, another module could also prove equally as useful, the Pyglet module. Pyglet simplicity makes it much more easy to use than some other modules, and it has also been shown to be quite fast regarding processing speed[2]. Despite this, however, Pyglet documentation has suffered from a lack of maintence online, where many tutorials and documents remain out of date, and may not be usable[2].
\\ 
\\
\indent Our third and last option for debugging is to not display any variables or data to the user. Our reasoning for considering this option is to keep our program even more simple that the previous options. The other options we've examined give the user variables and data that can be manipulated to change the results of the program. However, the other options run into issues that can be solved by utilizing not displaying any sort of variables or data, since it removes any sort of issue where the user may forget to leave a prove in their program, or if they overwhelmed with the assortment of variables and data. This ensures that everything is kept in the background, out of the user's reach. However, this also means that the user will miss out on certain aspects of aforementioned options. Obviously, choosing this option would not require the implementation of any new technology.
\\
% Code Commenting and Intext Guides: Comment Blocks vs Datasheet Refrence (like a Manpage) vs Text Comment in Blocks
% Comment Blocks: Helpful comments within the code 
% Datasheet Refrence: Similar to Man pages
% Text Comment in Blocks: Comments within Block features
\newpage
\noindent \textbf{Comments and Guides} 
\\
\\
\indent The first option we considered for commenting and guides is to include comment blocks within our code. Our design of these comment blocks would consist of including helpful comments scattered throughout our code that would give the user some guidance on how the inter workings of the program functions. These comments would be placed in such areas where the user will be fully able to understand just what is happening in their program. The reason we chose to consider this option is that it will keep more technical information in the background, away from the user and allow them to focus on the more simple interface of our program. Compared to the other two options, this one remains rather simple, in that the user does have the option to seek out these comment blocks while also able to run their program as intended. However, these comment blocks may not be easily accessible by the user if they are not aware of how to access them. Additionally, if the user is able to access these comment blocks, they are at risk of changing some of the program's code, either accidentally or on purpose. This could prove to be a major issue since it may impact the results of their program. 
\\
\\
\indent Our second option we looked at for commenting and guides was to include reference datasheets. These datasheets would functional similar to man pages, and would give the user an overview of certain information. Some examples of datasheets would include various types of Blocks, how a certain method works operates, or what the properties of a specific class are. Our reasoning for looking into reference datasheets is that it will keep all relevant information pertaining to a particular topic in a single place. This means that, unlike comment blocks, the user will not need to go searching through code for specific information. However, due the the general overview of datasheets and the large amount of data they can carry, the user may still have a difficult time locating the information they are searching for. Creating reference datasheets also requires the use of certain typesetting. A program that could help with this is nroff, a Unix text formatting program. This particular program is used in the Unix help system to format and display man pages[3].
\\
\\
\indent The last option we considered for commenting and guides is to include helpful comments inside Blocks. These comments will help the user understand what is happening within the Block, without interrupting or changing their program. Similar to the reference datasheets, these Block comments would include information such as Block type, methods used, and variables passing through the Block. Our reason for looking at this particular option is that we want to integrate helpful information into the program itself, rather than having the user search through the code or comb through datasheets. Compared to the other options, this one allows the user to see the information on the go and it will always be relevant information. Additionally, this also means that the user will not be searching through the code for comment blocks, and thus will prevent them from accidentally changing any code. Compared to the other options for commenting and guides, this particular option keep our program simple and straightforward. Similar to the probe option in the debugging section, this option could make use of either Tkinter or Pyglet modules to give the user the information they need.
\\
% Flexibility: Allow Custom Functions vs All Built-In Functions vs Function Package Files (Pre-Packaged Libraries)
% Allow Custom Functions: Users can create their own Block functions
% All Built-In Functions: All functions are built in prior to user interaction
% Function Package Files: Base functions are installed, with add-on functions available
\newpage
\noindent \textbf{Flexibility}
\\
\\
\indent The first option we looked at for flexibility was to allow the user to create their own custom functions, or in this case, their own Block types. These Blocks would be completely customize able for whatever the user's program needs, giving the user more control of their program's flow. Our reason for considering this option is that the user may need additional features for their Blocks that are unique to their program. This does mean, however, that it is possible the user may create a Block that simple does not function with the rest of the program, or contains features that other Blocks are not capable of accommodating. Additionally, giving user's the freedom of custom Block types adds another layer of complexity, and somewhat strays away from our goal to keep the program as simple as possible.
\\
\\
\indent The second option we considered for flexibility was to have all Block types be built in prior to the initial installation. These Block types would cover a broad spectrum of features and properties that the user will have access to when designing their program. Our reason for considering this option is that our main goal is to keep the our program as simple as possible regarding user interaction. This particular option effectively makes using our program much more simple for the user since they will not need to worry about creating their own Blocks and instead are given a list of predetermined Blocks they can use. This does, however, run into some issues. If the user needs a certain Block for their program and that Block is not in the built in list, they will not be able to apply such an implementation to their program. Additionally, the user may not need all of the Blocks in the built in list, which could make finding and utilizing these Blocks a hassle for the user.
\\
\\
\indent The third and last option we examined for flexibility was to build in a minimal amount of Block types during installation, and to include prepackaged libraries with additional Block types. These prepackaged Block types would apply much more complex and sophisticated functions compared to the Block types already installed. Our reason for looking at this option is to give the user a basic amount of Blocks to build their program with, enough so that any user can be adequately accommodated. If a particular user needed different Block types, they can simply install one of the related libraries and continue building their program. Of course this option does run into some glaring issues, however. Once the user has installed the packaged library, those Block types will remain in their list of installed Blocks, taking up space and making it more difficult for the user to find less complex Blocks. On the other hand, this option could allow for the user to simply uninstall those packaged libraries once they have finished with their program. Compared to the other options for flexibility, this particular one seems to allow for a diverse range of simplicity while keeping room for more complex operations. This option would function in a manner similar to Cygwin, where a default set of packages is installed during the initial setup and additional modules can be seemlessly downloaded as needed by the user[4].
\\
\newpage
\begin{thebibliography}{1}
\bibitem{meyers} Chris Meyers. (2015) {\em Building a GUI Application with Tkinter} [Online]. Available: http://www.openbookproject.net/py4fun/gui/tkPhone.html
\\
\bibitem{johnson} Stephen Johnson. (2009) {\em Pyglet Tutorial} [Online]. Available: http://steveasleep.com/pyglettutorial.html
\\
\bibitem{armstrong} James C. Armstrong and David B. Horvath. {\em Basic Formatting with troff/nroff} [Online]. Available: http://cmd.inp.nsk.su/old/cmd2/manuals/unix/UNIX\_Unleashed/ch08.htm
\\
\bibitem{moody} George B. Moody. (2003) {\em An Introduction to Cygwin} [Online]. Available: https://www.physionet.org/physiotools/cygwin/
\\
\end{thebibliography}
\end{document}